c
applied_discount_names
c
applied_discount_names
c
applied_discount_names
c
applied_discount_names
c
applied_discount_names
group_discount.name
group_discount
c
pos_items_array_with_only_qualifying_items
qualifying_groups
qualifying_groups.size
group_discount
c
number_of_qualifying_groups
total_discount_to_apply
qualifying_groups
c
qualifying_groups
pos_items_array_with_only_qualifying_items
c
pos_items_array_with_only_qualifying_items
c
pos_items_array_with_only_qualifying_items
applicable_product_ids
c
pos_items_array
applicable_product_items
pos_items_array
pos_items_array_with_only_qualifying_items
applicable_product_items
c
qualifying_groups = pos_items_array_with_only_qualifying_items.sort_by do |item|
      [item[:qty], Product.find(item[:product_id]).price_cents]
    end
pos_items_array_with_only_qualifying_items = pos_items_array.select do |item|
      applicable_product_items.include?(item[:product_id])
    end
applicable_product_items = current_group_discounts.flat_map(&:matching_product_ids)
current_group_discounts = Discount.active.current.type_group
pos_items_array
c
self.discount_filters
self
c
self.persisted?
self.discount_filters
self.matching_products
self
discount_filters
matching_products.count
matching_products
c
discount_filters.where(filterable_type: 'Tag').exists?
discount_filters
matching_products.count
matching_products
c
@requisition.errors
@requistion.errors
c
@total_sales
c
@total_sales
@orders.first
@orders.count
@orders
c
@options
@notifiable
@strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
medium[0]
medium[1]
medium.class
medium
c
notification_setting
c
@strategy.notification_type
@options
@strategy
@notifiable
c
line = @stock_transfer.stock_transfer_lines.find(line_id)
line.update!(received_quantity: quantity.to_i)
line = @stock_transfer.stock_transfer_lines.find(line_id)
quantity
line_id
received_quantities
c
pp @order
@order
c
@current_location
c
@current_location
c
@current_cashier_shift = @current_cashier&.current_shift(current_user)
@current_cashier = current_cashier || @current_location&.cashiers&.first
@current_location&.cashiers
@current_location
session[:current_cashier_id]
current_cashier 
@current_warehouse
Location.find(3)
Location.find(1)
session[:current_location_id]
c
Location.find(1)
session[:current_location_id]
c
@combo_product.errors
@combo_product
c
@invoice_result[:status]
c
@invoice_result[:status]
@invoice_result
c
response
c
@invoice_result[:message]
@invoice_result[:status]
@invoice_result = @order.universal_invoice_show
@order = Order.find(params[:id])
@order
c
@elligible_locations
c
@elligible_locations
@elligible_locations.one?
c
@elligible_locations.one?
@elligible_locations
c
@user_attendance_log
existing_log = UserAttendanceLog.find_by(user: @user_attendance_log.user, location: @user_attendance_log.location, checkout: nil)
@user_attendance_log.location
@user_attendance_log.lcation
@user_attendance_log
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
rounded_value
c
tier
c
last_free_product = @user.user_free_products.available.find_by(product: product, loyalty_tier: loyalty_tier)
loyalty_tier = tier
product = product
last_free_product = @user.user_free_products.available.find_by(product: product, loyalty_tier: loyalty_tier)
@user
@user.
free_product_available?(product, tier)
product = Product.find_by(id: tier.free_product_id)
tier&.free_product_id
tier
c
@user.orders_in_last_12_months.count
@user
c
@user
c
user
@user
c
self.user
self
c
@order
c
@order.user_id
User.find(get_generic_customer_id)&.id
User.find_by!(email: "generic_customer@devtechperu.com")&.id
c
@order.user
c
@order.user
User.find(get_generic_customer_id)&.id
@order.user_id
@order
c
self.seller
self.user
self.customer
self.user
self
c
user
@user
c
@location.errors
c
value
c
value
c
value
c
value
c
value
c
value.class
value
c
@company_goals
c
@company_goals
c
@company_goals = {
          series: pie_chart_data.map { |data| data[:y] },
          labels: pie_chart_data.map { |data| data[:name] },
          colors: pie_chart_data.map { |data| data[:color] },
          total_sales: total_sales
        }
pie_chart_data = @commission_ranges.map.with_index do |range, index|
          max_value = range.max_sales || (range.min_sales * 2)  # For the last range without max_sales
          value = [ total_sales - range.min_sales, 0 ].max
          value = [ value, max_value - range.min_sales ].min
          {
