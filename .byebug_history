c
@current_location
c
@locations
c
@locations
c
@locations.class
@locations
Location.active.order(:name)
current_user&.location_id
@current_location
current_user
pp @locations
@locations
c
Commission.last
Commission.joins(order: :location)
          .where(user: @seller)
Commission.joins(order: :location)
          .where(user: @seller)
          .where(orders: { created_at: start_date.beginning_of_day..end_date.end_of_day })
c
Commission.last
@seller
Order.last
Order.active.paid
          .where(seller: @seller)
          .where(created_at: start_date.beginning_of_day..end_date.end_of_day)
location_id
locations.name
end_date.end_of_day
start_date.beginning_of_day
@seller
c
SellerBiweeklySalesTarget.period_date_range(@current_period)
@current_period
c
@total_sales
c
@total_sales
c
SellerBiweeklySalesTarget.period_date_range(@current_period)
@current_period
@total_sales = Order.where(location: @current_chosen_location).count
@current_chosen_location
c
seller_data[:user_id].blank?
seller_data[:percentage].to_f.zero?
seller_data = sellers_array.first
@order.commissions.joins(:commission_payout).exists?
sellers_array
c
sellers_hash
c
@strategy.notification_type
c
@strategy.notification_type
NotificationSetting.for(@strategy.notification_type)
@strategy.notification_type
@strategy
c
params
@seller_biweekly_sales_target.errors
@seller_biweekly_sales_target
c
params[:location][:commission_ranges_attributes]
@location.commission_ranges.first
c
@commission_range = @location.commission_ranges.first
params[:location][:commission_ranges_attributes].present?
params[:location][:commission_ranges_attributes]
c
@location.errors
@commission_range
@commission_range.errors
c
sellers = User.with_role("seller").where(internal: false, location_id: params[:location_id] || @current_location&.id)
@current_location&.id
params
c
params
params[:tag_ids]
c
current_group_discounts
applicable_product_ids
current_group_discounts
applied_discount_counts
number_of_qualifying_groups
total_discount_to_apply
sorted_items
c
sorted_items
c
applied_discount_names
c
applied_discount_names
c
applied_discount_names
c
applied_discount_names
c
applied_discount_names
group_discount.name
group_discount
c
pos_items_array_with_only_qualifying_items
qualifying_groups
qualifying_groups.size
group_discount
c
number_of_qualifying_groups
total_discount_to_apply
qualifying_groups
c
qualifying_groups
pos_items_array_with_only_qualifying_items
c
pos_items_array_with_only_qualifying_items
c
pos_items_array_with_only_qualifying_items
applicable_product_ids
c
pos_items_array
applicable_product_items
pos_items_array
pos_items_array_with_only_qualifying_items
applicable_product_items
c
qualifying_groups = pos_items_array_with_only_qualifying_items.sort_by do |item|
      [item[:qty], Product.find(item[:product_id]).price_cents]
    end
pos_items_array_with_only_qualifying_items = pos_items_array.select do |item|
      applicable_product_items.include?(item[:product_id])
    end
applicable_product_items = current_group_discounts.flat_map(&:matching_product_ids)
current_group_discounts = Discount.active.current.type_group
pos_items_array
c
self.discount_filters
self
c
self.persisted?
self.discount_filters
self.matching_products
self
discount_filters
matching_products.count
matching_products
c
discount_filters.where(filterable_type: 'Tag').exists?
discount_filters
matching_products.count
matching_products
c
@requisition.errors
@requistion.errors
c
@total_sales
c
@total_sales
@orders.first
@orders.count
@orders
c
@options
@notifiable
@strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
custom_strategy
c
medium[0]
medium[1]
medium.class
medium
c
notification_setting
c
@strategy.notification_type
@options
@strategy
@notifiable
c
line = @stock_transfer.stock_transfer_lines.find(line_id)
line.update!(received_quantity: quantity.to_i)
line = @stock_transfer.stock_transfer_lines.find(line_id)
quantity
line_id
received_quantities
c
pp @order
@order
c
@current_location
c
@current_location
c
@current_cashier_shift = @current_cashier&.current_shift(current_user)
@current_cashier = current_cashier || @current_location&.cashiers&.first
@current_location&.cashiers
@current_location
session[:current_cashier_id]
current_cashier 
@current_warehouse
Location.find(3)
Location.find(1)
session[:current_location_id]
c
Location.find(1)
session[:current_location_id]
c
@combo_product.errors
@combo_product
c
@invoice_result[:status]
c
@invoice_result[:status]
@invoice_result
c
response
c
@invoice_result[:message]
@invoice_result[:status]
@invoice_result = @order.universal_invoice_show
@order = Order.find(params[:id])
@order
c
@elligible_locations
c
@elligible_locations
@elligible_locations.one?
c
@elligible_locations.one?
@elligible_locations
c
@user_attendance_log
existing_log = UserAttendanceLog.find_by(user: @user_attendance_log.user, location: @user_attendance_log.location, checkout: nil)
@user_attendance_log.location
@user_attendance_log.lcation
@user_attendance_log
c
rounded_value
c
rounded_value
c
rounded_value
